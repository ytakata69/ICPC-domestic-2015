# Problem G: Go around the Labyrinth

解答例

- Main.java - 再帰呼び出ししない。
    - 左・前・右がふさがっていたら，真後ろを向いて前進する。
人が左手の法則で迷路を歩く様子に近い。
- Main2.java - バックトラック法。左・前・右がふさがっていたらバックトラックする。

## 非再帰版 (Main.java)

「左・前・右・後の順に進めるか調べ，okなら進む」ことを繰り返す。

引き返すときは一度通ったところを通るので，同じ箇所を繰り返し通ってもよいことにしなければならない。
しかし，下図のように，宝 (`$`) を取った後で同じ箇所を通るのはダメ (`>` `v` `<` `^` が順路を表す)。

```
>>>>>>>$
....#^.v
....#^<<
....####
```

そこで，通った箇所に「持っている宝の数」を書いておき，古い数の箇所に来たら「失敗」と判断する (下図)
(「『持っている宝の数』を減らして探索を続ける」でもよいが，どうせこの宝を取ることは不可能なので，ここで探索を打ち切って構わない)。

```
0000000$
....#1.1
....#111
....####
```

左手の法則を続ければいずれ必ず出発地点に戻る (壁で囲まれていて到達できない宝はあり得るが，出発地点には必ず戻ってこれる)。そのときに全部の宝を持っていれば成功，持っていなければ失敗。

なお，ループの末尾 (83行目) に以下の行があるが，この行が必要になるのは，出発地点が壁で囲まれていて一歩も進めない場合のみである。

```java
  if (d > 2) { return false; } // 4方向ともふさがっている
```

## バックトラック法 (Main2.java)

「左・前・右に進めるか調べ，okなら進む。3方向ともダメならバックトラックする」。

「一度通ったところは通らない (壁だと見なす)」としてよい。

「持っている宝の数」(変数`gold`) を増やす位置に注意。再帰呼び出しから戻ったときには元の値に戻さないといけないので，「再帰呼び出し前に増やして復帰時に元に戻す」か，「呼び出し先で増やす (呼び出し元では増やさない)」ようにする必要がある。解答例では後者を選んでいる。
